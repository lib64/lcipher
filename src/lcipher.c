#include "lcipher.h"

#include <string.h>

static const uint32_t key_seed[ROUNDS] = {
    0x73e64b14,
    0x6494c622,
    0xb005e632,
    0x500300bb,
    0x80312fe2,
    0x4dec32e0,
    0xd7f8d8ff,
    0x8d35d805,
};

static const char sbox_arr[SBOX_COUNT][SBOX_SIZE] = {

   {0x2e,0x2f,0x5b,0x75,0x29,0x5a,0x7f,0x7c,
    0x12,0x26,0x68,0x37,0x5c,0x49,0x6e,0x7d,
    0x3a,0x42,0x72,0x1f,0x2a,0x19,0x44,0x6f,
    0x6d,0x34,0x4e,0x31,0x22,0x33,0x16,0x20,
    0x56,0x57,0x0e,0x54,0x4c,0x74,0x41,0x35,
    0x7b,0x40,0x59,0x2b,0x14,0x3e,0x66,0x79,
    0x5d,0x27,0x61,0x43,0x0d,0x21,0x6c,0x47,
    0x70,0x48,0x25,0x32,0x73,0x45,0x0c,0x39,
    0x71,0x58,0x55,0x7e,0x1c,0x00,0x64,0x07,
    0x13,0x78,0x23,0x0b,0x67,0x6b,0x7a,0x0a,
    0x4d,0x2d,0x04,0x46,0x4b,0x36,0x76,0x10,
    0x69,0x24,0x01,0x2c,0x4a,0x03,0x77,0x65,
    0x51,0x52,0x11,0x1a,0x62,0x3d,0x06,0x3f,
    0x50,0x1d,0x0f,0x53,0x1e,0x38,0x02,0x15,
    0x6a,0x05,0x28,0x09,0x30,0x63,0x08,0x17,
    0x18,0x5f,0x1b,0x5e,0x3b,0x3c,0x4f,0x60},
    
   {0x53,0x37,0x54,0x6a,0x1f,0x55,0x66,0x63,
    0x12,0x1d,0x6f,0x0a,0x0e,0x24,0x59,0x02,
    0x3a,0x1e,0x46,0x72,0x2f,0x6c,0x31,0x65,
    0x34,0x0f,0x22,0x43,0x5d,0x49,0x14,0x5f,
    0x4a,0x3f,0x76,0x79,0x5b,0x2d,0x7b,0x3e,
    0x33,0x5c,0x08,0x4b,0x04,0x0c,0x09,0x47,
    0x64,0x56,0x0b,0x26,0x18,0x3c,0x67,0x15,
    0x28,0x3b,0x71,0x41,0x2c,0x7f,0x6b,0x13,
    0x32,0x3d,0x78,0x77,0x45,0x51,0x38,0x62,
    0x74,0x61,0x27,0x30,0x35,0x44,0x7d,0x16,
    0x29,0x42,0x6e,0x40,0x5e,0x25,0x0d,0x03,
    0x1b,0x48,0x10,0x58,0x4d,0x6d,0x11,0x23,
    0x7a,0x68,0x21,0x69,0x52,0x20,0x06,0x7c,
    0x4e,0x2a,0x19,0x75,0x50,0x70,0x1a,0x17,
    0x01,0x73,0x60,0x05,0x2e,0x07,0x7e,0x1c,
    0x2b,0x4f,0x36,0x4c,0x57,0x39,0x5a,0x00},
    
   {0x54,0x7c,0x76,0x5c,0x36,0x00,0x57,0x23,
    0x6a,0x6c,0x48,0x0e,0x70,0x67,0x15,0x62,
    0x5e,0x77,0x37,0x4c,0x2a,0x63,0x3c,0x04,
    0x07,0x08,0x31,0x03,0x30,0x39,0x27,0x79,
    0x1b,0x2c,0x6d,0x28,0x1a,0x11,0x0a,0x50,
    0x17,0x74,0x0c,0x71,0x10,0x1f,0x6f,0x1c,
    0x69,0x13,0x41,0x64,0x58,0x16,0x3d,0x3a,
    0x44,0x05,0x40,0x2b,0x34,0x5d,0x49,0x38,
    0x7e,0x66,0x7b,0x2d,0x7a,0x51,0x55,0x45,
    0x0d,0x14,0x4e,0x02,0x6e,0x61,0x4f,0x06,
    0x0b,0x56,0x78,0x1d,0x73,0x59,0x5b,0x60,
    0x12,0x6b,0x72,0x75,0x7f,0x24,0x25,0x35,
    0x65,0x20,0x68,0x1e,0x09,0x53,0x47,0x0f,
    0x33,0x46,0x32,0x3f,0x22,0x4a,0x2f,0x52,
    0x01,0x2e,0x4b,0x19,0x3e,0x26,0x7d,0x29,
    0x5a,0x18,0x3b,0x42,0x21,0x5f,0x43,0x4d},
    
   {0x61,0x17,0x0c,0x2f,0x7e,0x45,0x7f,0x4e,
    0x22,0x35,0x39,0x1d,0x14,0x60,0x33,0x27,
    0x75,0x20,0x3b,0x44,0x0f,0x77,0x4b,0x51,
    0x2c,0x2d,0x42,0x12,0x4a,0x0b,0x43,0x02,
    0x01,0x62,0x18,0x3c,0x24,0x2b,0x57,0x65,
    0x5e,0x04,0x36,0x2e,0x05,0x10,0x72,0x74,
    0x40,0x5c,0x47,0x1e,0x4f,0x21,0x3f,0x46,
    0x76,0x37,0x06,0x03,0x4d,0x29,0x1a,0x6a,
    0x59,0x53,0x67,0x32,0x56,0x64,0x4c,0x09,
    0x5d,0x58,0x25,0x78,0x3e,0x3a,0x73,0x08,
    0x7b,0x50,0x41,0x07,0x5a,0x7c,0x34,0x5f,
    0x15,0x48,0x6b,0x6e,0x7a,0x19,0x1b,0x66,
    0x7d,0x0d,0x54,0x3d,0x63,0x31,0x0e,0x6c,
    0x30,0x13,0x69,0x68,0x16,0x49,0x71,0x52,
    0x00,0x11,0x1c,0x23,0x79,0x28,0x0a,0x55,
    0x38,0x6f,0x70,0x6d,0x1f,0x5b,0x26,0x2a}
    
};

static const char pbox[PBOX_SIZE] = {0x01,0x00,0x03,0x02};

static void lc_f(const lc_ctx *ctx, size_t round, const char *input, char *output)
{
    char tmp[FINPUT_SIZE];
    char *key_str = (char *)(ctx->key_arr + round);
    
    // key xor
    for(size_t i = 0; i < FINPUT_SIZE; i++) {
        tmp[i] = key_str[i] ^ input[i];
    }
    
    // substitution
    for(size_t i = 0; i < SBOX_COUNT; i++) {
        tmp[i] = sbox_arr[i][ (int)tmp[i] ];
    }
    
    // 16 bit pseudo hadamard transform 
    //
    //  a' = a + b  mod 2**16
    //  b' = a + 2b mod 2**16
    //
    uint16_t *a = (uint16_t *)tmp;
    uint16_t *b = (uint16_t *)(tmp+2);
    uint16_t a_prime = *a + *b % PHT_MAX;
    uint16_t b_prime = *a + (2 * *b) % PHT_MAX;
    *a = a_prime;
    *b = b_prime;

    // permutation
    for(size_t i = 0; i < PBOX_SIZE; i++) {
        output[i] = tmp[ (int)pbox[i] ];
    }
}

static void lc_round(const lc_ctx *ctx, size_t round, const char *input, char *output)
{
    const char *input_right = input + FINPUT_SIZE;
    
    // fout = f(input_right)
    char fout[FINPUT_SIZE];
    lc_f(ctx, round, input_right, fout);
    
    // output_right = fout ^ input_left
    for(size_t i = 0; i < FINPUT_SIZE; i++) {
        output[i + FINPUT_SIZE] = fout[i] ^ input[i];
    }
    
    // output_left = input_right
    for(size_t i = 0; i < FINPUT_SIZE; i++) {
        output[i] = input_right[i];
    }
}

void lc_ctx_expand(lc_ctx *ctx, const char *passphrase, size_t pass_size)
{
    memcpy(ctx->key_arr, key_seed, sizeof(uint32_t) * ROUNDS);
    
    for(size_t i = 0; i < pass_size; i++) {
        for(int j = 0; j < ROUNDS; j++) {
            ctx->key_arr[j] ^= passphrase[i];
        }
    }
}

void lc_ctx_invert(lc_ctx *ctx)
{
    uint32_t inv[ROUNDS];
    
    size_t count = 0;
    for(size_t i = ROUNDS; i > 0; i--) {
        inv[i-1] = ctx->key_arr[count++];
    }
    
    for(size_t i = 0; i < ROUNDS; i++) {
        ctx->key_arr[i] = inv[i];
    }
}

static void lc_block(const lc_ctx *ctx, const char *input, char *output)
{
    char in[BLOCK_SIZE];
    char out[BLOCK_SIZE];
    
    memcpy(in, input, BLOCK_SIZE);
    
    for(size_t i = 0; i < ROUNDS; i++) {
        lc_round(ctx, i, in, out);
        memcpy(in, out, BLOCK_SIZE);
    }
   
    // undo the swap that lc_round performed the final time.
    output[0] = out[4];
    output[1] = out[5];
    output[2] = out[6];
    output[3] = out[7];
    output[4] = out[0];
    output[5] = out[1];
    output[6] = out[2];
    output[7] = out[3];    
}

void lc_encrypt_buffer(const lc_ctx *ctx, const char *iv, const char *input, size_t insz, char *output)
{

    size_t block_count = insz / BLOCK_SIZE;
    size_t remaining = insz % BLOCK_SIZE;
    
    char tmp[BLOCK_SIZE];
    size_t out_counter = 0;
    
    // write the iv to output
    memcpy(output, iv, BLOCK_SIZE);
    out_counter += BLOCK_SIZE;
    
    // encrypt all of the full blocks
    for(size_t i = 0; i < block_count; i++) {
    
        const char *current_block = input + (i * BLOCK_SIZE);
        
        // xor input block with iv
        for(size_t x = 0; x < BLOCK_SIZE; x++) {
            tmp[x] = current_block[x] ^ iv[x];
        }
        
        lc_block(ctx, tmp, (output + out_counter) );
        out_counter += BLOCK_SIZE;
    }
     
    char final_block[BLOCK_SIZE];
    memset(final_block, 0, BLOCK_SIZE);
    
    const char *current_block = input + (block_count * BLOCK_SIZE);
    
    // write remaining message bytes to final block
    for(size_t i = 0; i < remaining; i++) {
        final_block[i] = current_block[i];
    }
    
    // write padding to final block
    size_t final_count = remaining;
    while(final_count < BLOCK_SIZE-1) {
        final_block[final_count++] = 0;
    }
    
    // write padding length byte to the end of the block
    final_block[BLOCK_SIZE-1] = (char)BLOCK_SIZE - remaining - 1;
    
    // xor final block with iv
    for(int x = 0; x < BLOCK_SIZE; x++) {
        tmp[x] = final_block[x] ^ iv[x];
    }
    
    lc_block(ctx, tmp, (output + out_counter) );
}


void lc_decrypt_buffer(const lc_ctx *ctx, const char *input, size_t insz, char *output)
{
    size_t block_count = insz / BLOCK_SIZE;
    
    char tmp[BLOCK_SIZE];
    char iv[BLOCK_SIZE];
    
    size_t out_counter = 0;
    
    // read the iv from input
    memcpy(iv, input, BLOCK_SIZE);
    
    // decrypt all of the blocks
    for(size_t i = 1; i < block_count; i++) {
    
        const char *current_block = input + (i * BLOCK_SIZE);
        lc_block(ctx, current_block, tmp );
        
        // xor input block with iv
        for(size_t x = 0; x < BLOCK_SIZE; x++) {
            (output+BLOCK_SIZE * i)[x] = tmp[x] ^ iv[x];
        }
        
        // strip the padding and padding length byte from the last block
        if(i == block_count -1) {
            char padding = (output+BLOCK_SIZE * i)[BLOCK_SIZE -1];
            if(padding < BLOCK_SIZE) {
                memset( (output+BLOCK_SIZE * i) + (BLOCK_SIZE-padding-1), 0, padding+1  );
            } else {
                printf("bad padding size, decryption may have failed.\n");
            }

        }
        
        out_counter += BLOCK_SIZE;
    }
}

size_t lc_output_size(size_t insz)
{
    return insz + BLOCK_SIZE - (insz % BLOCK_SIZE) + BLOCK_SIZE;
}











